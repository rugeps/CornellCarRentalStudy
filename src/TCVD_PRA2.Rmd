---
title: 'M2.951 - Tipologia i cicle de vida de les dades'
subtitle: 'Pràctica 2 - Neteja i anàlisi de les dades'
author: 'Autors: Roger Perís Serrano i Albert Cámara Viñals'
date: '`r format(Sys.Date(), "Desembre, %Y")`'
output:
  pdf_document:
    latex_engine: xelatex
    highlight: zenburn
    toc: yes
    toc_depth: 3
    number_sections: true
    keep_tex: true
    fig_width: 5
    fig_height: 3 
  html_document:
    highlight: default
    number_sections: yes
    theme: cosmo
    toc: yes
    toc_depth: 3
    includes:
      in_header: header.html
bibliography: bibliography_tcvd_pra_2.bib    
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Detalls de l'activitat

## Presentació

En aquesta pràctica s’elabora un cas pràctic orientat a aprendre a identificar les dades rellevants per un projecte analític i usar les eines d’integració, neteja, validació i anàlisi de les mateixes. Per fer aquesta pràctica haureu de treballar en grups de 2 persones. Haureu de lliurar un sol fitxer amb l’enllaç Github (https://github.com) on es trobin les solucions incloent els noms dels components de l’equip. Podeu utilitzar la Wiki de Github per descriure el vostre equip i els diferents arxius que corresponen a la vostra entrega. Cada membre de l’equip haurà de contribuir amb el seu usuari Github. Malgrat que no es tracta del mateix enunciat, els següents exemples d’edicions anteriors us poden servir com a guia:

* Exemple: https://github.com/Bengis/nba-gap-cleaning
* Exemple complex (fitxer adjunt).

## Competències

En aquesta pràctica es desenvolupen les següents competències del Màster de Data Science:

* Capacitat d'analitzar un problema en el nivell d'abstracció adequat a cada situació i aplicar les habilitats i coneixements adquirits per abordar-lo i resoldre'l.
* Capacitat per aplicar les tècniques específiques de tractament de dades (integració, transformació, neteja i validació) per al seu posterior anàlisi.

## Objectius

Els objectius concrets d’aquesta pràctica són:

* Aprendre a aplicar els coneixements adquirits i la seva capacitat de resolució de problemes en entorns nous o poc coneguts dintre de contextos més amplis o multidisciplinaris.
* Saber identificar les dades rellevants i els tractaments necessaris (integració, neteja i validació) per dur a terme un projecte analític.
* Aprendre a analitzar les dades adequadament per abordar la informació continguda en les dades.
* Identificar la millor representació dels resultats per tal d’aportar conclusions sobre el problema plantejat en el procés analític.
* Actuar amb els principis ètics i legals relacionats amb la manipulació de dades en funció de l'àmbit d'aplicació.
* Desenvolupar les habilitats d'aprenentatge que els permetin continuar estudiant d'una manera que haurà de ser en gran manera autodirigida o autònoma.
* Desenvolupar la capacitat de cerca, gestió i ús d'informació i recursos en l'àmbit de la ciència de dades.


## Descripció de la Pràctica a realitzar

L’objectiu d’aquesta activitat serà el tractament d’un dataset, que pot ser el creat a la pràctica 1 o bé qualsevol dataset lliure disponible a Kaggle (https://www.kaggle.com). Alguns exemples de dataset amb els que podeu treballar són:

* Red Wine Quality (https://www.kaggle.com/uciml/red-wine-quality-cortez-et-al-2009 ).
* Titanic: Machine Learning from Disaster (https://www.kaggle.com/c/titanic ).

L’últim exemple correspon a una competició activa a Kaggle de manera que, opcionalment, podeu aprofitar el treball realitzat durant la pràctica per entrar en aquesta competició.

Seguint les principals etapes d’un projecte analític, les diferents tasques a realitzar (i justificar) són les següents:

1. Descripció del dataset. Perquè és important i quina pregunta/problema pretén respondre?
2. Integració i selecció de les dades d’interès a analitzar.
3. Neteja de les dades.
  + Les dades contenen zeros o elements buits? Com gestionaries aquests casos?
  + Identificació i tractament de valors extrems.
4. Anàlisi de les dades.
  + Selecció dels grups de dades que es volen analitzar/comparar (planificació delsanàlisis a aplicar).
  + Comprovació de la normalitat i homogeneïtat de la variància.
  + Aplicació de proves estadístiques per comparar els grups de dades. En funció de les dades i de l’objectiu de l’estudi,     aplicar proves de contrast d’hipòtesis, correlacions, regressions, etc. Aplicar almenys tres mètodes d’anàlisi             diferents.
5. Representació dels resultats a partir de taules i gràfiques.
6. Resolució del problema. A partir dels resultats obtinguts, quines són les conclusions? Els resultats permeten respondre al problema?
7. Codi: Cal adjuntar el codi, preferiblement en R, amb el que s’ha realitzat la neteja, anàlisi i representació de les dades. Si ho preferiu, també podeu treballar en Python.

## Recursos

Els següents recursos són d’utilitat per la realització de la pràctica:

* Calvo M., Subirats L., Pérez D. (2019). Introducción a la limpieza y análisis de los datos. Editorial UOC.
* Megan Squire (2015). Clean Data. Packt Publishing Ltd.
* Jiawei Han, Micheine Kamber, Jian Pei (2012). Data mining: concepts and techniques. Morgan Kaufmann.
* Jason W. Osborne (2010). Data Cleaning Basics: Best Practices in Dealing with Extreme Scores. Newborn and Infant Nursing Reviews; 10 (1): pp. 1527-3369.
* Peter Dalgaard (2008). Introductory statistics with R. Springer Science & Business Media.
* Wes McKinney (2012). Python for Data Analysis. O’Reilley Media, Inc.
* Tutorial de Github https://guides.github.com/activities/hello-world.

## Criteris de valoració

Tots els apartat són obligatoris. La ponderació dels exercicis és la següent:

* Els apartats 1, 2 i 6 valen 0,5 punts.
* Els apartats 3, 5 i 7 valen 2 punts.
* L’apartat 4 val 2,5 punts.

Es valorarà la idoneïtat de les respostes, que han de ser clares i completes. Les diferents etapes han d’estar ben justificades i acompanyades del codi corresponent. També es valorarà la síntesi i claredat, a través de l’ús de comentaris, del codi resultant, així com la qualitat de les dades finals analitzades.

## Format i data de lliurament

Durant la setmana del 21 al 25 de desembre el grup podrà lliurar al professor una entrega parcial opcional. Aquesta entrega parcial és molt recomanable per tal de rebre assessorament sobre la pràctica i verificar que la direcció presa és la correcta. Es lliuraran comentaris als estudiants que hagin efectuat l’entrega parcial però no comptarà per la nota de la pràctica. En l’entrega parcial els estudiants hauran de lliurar per correu electrònic, al profesor encarregat de l’aula, l’enllaç al repositori Github amb el que hagin avançat.

Pel que fa a l’entrega final, cal lliurar un únic fitxer que contingui l’enllaç a Github, el qual no es podrà modificar posteriorment a la data d’entrega, on hi hagi:

1. Una Wiki on hi hagi els noms dels components del grup i una descripció dels fitxers.
2. Un document Word, Open Office o PDF amb les respostes a les preguntes i els noms
dels components del grup. A més, al final de document, haurà d’aparèixer la següent taula
de contribucions al treball, la qual ha de signar cada integrant del grup amb les seves
inicials. Les inicials representen la confirmació de que l’integrant ha participat en aquell apartat. Tots els integrants han de participar en cadascun dels apartats, de manera que,
idealment, els apartats hauran d’estar signats per tots els integrants.
3. Una carpeta amb el codi generat per analitzar les dades.
4. El fitxer CSV amb les dades originals.
5. El fitxer CSV amb les dades finals analitzades.

Aquest document de l’entrega final de la Pràctica 2 s’ha de lliurar a l’espai de Lliurament i Registre d’AC de l’aula abans de les 23:59 del dia 5 de gener. No s’acceptaran lliuraments fora de termini.

\newpage
# Resolució

Contribucions               | Firma
-------------               | -------------
Investigació prèvia         | RPS, ACV
Redacció de les respostes   | RPS, ACV
Desenvolupament codi        | RPS, ACV

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Carreguem les llibreries que farem servir
library(tidyverse)
library(ggplot2)
library(dplyr)
library(GGally)
library(arules)
library(reshape2)
library(regclass)
library(car)
library(nortest)
library(gridExtra)
library(ResourceSelection)
library(DescTools)
library(vcd)
library(ggpubr)
library(corrplot)
library(rpart)
library(rpart.plot)
library(gmodels)
library(rattle)
library(Metrics)
library(caret)
library(DMwR)
library(ROSE)
library(grid)
library(gridExtra)

old <- theme_set(theme_minimal())
```

```{r include = FALSE}
library(knitr)
library(formatR)
opts_chunk$set(tidy.opts=list(width.cutoff=60),tidy=TRUE)
```



## Descripció del dataset

El conjunt de dades que analitzarem serà: Cornell Car Rental Dataset, s'ha obtingut del repositori de dades Kaggle (https://www.kaggle.com/kushleshkumar/cornell-car-rental-dataset?select=CarRentalData.csv). Aquest joc de dades és un recull de registres de diferents portals de lloguer de vehicles a les principals ciutats d'Estats Units, i s'ha generat mitjançant *webscraping*, amb una extracció relitzada al Julol del 2020. Està format per 16 característiques (columnes o atributs) que presentan 5851 registres (files o observacions). Cada una de les obseravacions es correspon a les característiques d'un vehicle de lloguer.

Les característiques, atributs o variables per cada observació (es manté el nom original en anglès) són:

* *fuelType:* Tipus de combustible utilitzat pel vehicle. 
* *rating:* Qualificació acumulativa del cotxe per part dels clients
* *renterTripsTaken:* Nombre de viatges realitzats per aquest vehicle (durada desconeguda)
* *reviewCount:* Nombre de valoracions
* *location.city:* Ciutat en què es troba el vehicle
* *location.country:* País en què es troba el vehicle
* *location.latitude:* Coordenada geogràfica (latitud) en què es troba el vehicle
* *location.longitude:* Coordenada geogràfica (longitud) en què es troba el vehicle
* *location.state:* Estat en què es troba el vehicle
* *owner.id:* Identificador (ID) del propietàri del vehicle
* *rate.daily:* Tarifa diària en dòlars
* *vehicle.make:* Marca del vehicle 
* *vehicle.model:* Model del vehicle
* *vehicle.type:* Tipus de vehicle
* *vehicle.year:* Any del vehicle (matriculació)
* *airportcity:* Ciutat de l'aeroport més proper a la localització en què es troba el vehicle (normalment es des d'on es realitza el lloguer del vehicle).



## Importància i objectius de l'anàlisi

Amb l'entrada en vigor de les zones de zero emissions a les grans ciutats, la classificació de vehicles segons el seu grau de contaminació i de l'objectiu de zero emissions al 2050, promogut per la Comisió Euopea han generat un gran debat envers la compra o lloguer de vehicles. De fet hi ha diversos estudis que mostren que en els últims anys hi ha hagut un increment en el mercat de lloguer de vehicles o *renting*. Per tant a partir del joc de dades escollit "Cornell Car Rental Dataset" ens proposem:

- Realitzar una anàlisi detallada dels atributs propis del sector del lloguer de vehicles per tal d'extreuren nou coneixement i que aquest pugui aportar valor. 

- Dur a terme diferents contrastos d'hipótesis que permetin identificar propietats interessants subjacents en les mostres que puguin ser inferides respecte a la població.

- Generar un model que permeti preveure el preu per dia d’un automòbil de lloguer.

- Generar un model que permeti preveure, donades les característiques d'un vehicle de lloguer, si aquest serà llogat o no.

- Generar un model que pugui preveure els ingressos anuals que aportarà un automòbil de lloguer com a aproximació als beneficis que aportaria.


Aquests anàlisis són de gran rellevància en gairebé qualsevol sector relacionat amb el lloguer de vehicles. Per una banda pot resultar interessant per les agències de lloguer, ja que aquestes podran conèixer amb més detall els seus clients, i per tant generar ofertes personalitzades o decidir quin és el preu més adient o quin model de vehicle és més adequat per renovar la flota. D'altre banda també pot resultar interessant per a l'usuari final, ja que a partir de les seves necesitats podrà determinar si li convé llogar un vehicle o no o si el seu preu és correspont amb el del mercat actual.




## Neteja de dades

### Lectura de dades

En primer lloc, obrim el fitxer de dades i examinem el tipus de dades amb els que R ha interpretat cada variable. A més examinem també els valors resum de cada tipus de variable.

Comencem carregant el joc de dades en un dataframe d'*R*.

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Carreguem el joc de dades
ds <- read.csv('../data/CarRentalDataV1.csv', stringsAsFactors = FALSE, header = TRUE, sep=',', strip.white = TRUE)
```

Tot seguit examinem l'estructura del joc de dades, per validar que s'han interpetat correctament.

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Verifiquem les dimensions del joc de dades
dim(ds)

# Verifiquem l'estructura del joc de dades
str(ds)
```

A partir dels detalls anteriors podem veure que disposem d'un joc de dades amb 5851 observacions, amb 16 atributs o variables per observació i que el tipus de dades s'ha interpretat correctament.

### Previsualització de les dades d'interès

A continuació realitzem una previsualització, anàlisi visual de les dades, per intentar identificar les possibles anomalies, distribucions i característiques de les diferents variables.

Per això el primer que farem serà distingir les variables categòriques de les variables numèriques. la qual cosa ens facilitarà el tractament futur. 

```{r echo=TRUE, message=FALSE, warning=FALSE}
categorical_features_names = c('fuelType', 'location.city', 'location.country', 'location.state', 'owner.id', 'vehicle.make', 'vehicle.model', 'vehicle.type', 'airportcity') 

numeric_features_names = c('rating', 'renterTripsTaken', 'reviewCount', 'location.latitude', 'location.longitude', 'rate.daily', 'vehicle.year')
```

**Anàlisi univariant** 

Comencem visualitzant els principals descriptors estadístics de cadascuna de les variables numèriques.

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Mostrem un resum dels principals estadístics de cada variable
summary(ds[, numeric_features_names])
```

#### Anàlisi dels atributs numèrics
\hfill\break
Tot seguit visualitzem les distribucions dels valors de les variables numèriques.

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Calculem histogrames de les variables numèriques
hist01 <- ggplot(data=ds, aes(x=rating)) + geom_histogram(bins = 20) + xlab('Rating') + ylab('Freqüència')
hist02 <- ggplot(data=ds, aes(x=renterTripsTaken)) + geom_histogram(bins=30) + xlab('Renter Trips Taken') + ylab('Freqüència')
hist03 <- ggplot(data=ds, aes(x=reviewCount)) + geom_histogram(bins=30) + xlab('Review Count') + ylab('Freqüència')
hist04 <- ggplot(data=ds, aes(x=location.latitude)) + geom_histogram(bins=10) + xlab('Latitut') + ylab('Freqüència')
hist05 <- ggplot(data=ds, aes(x=location.longitude)) + geom_histogram(bins=10) + xlab('Longitut') + ylab('Freqüència')
hist06 <- ggplot(data=ds, aes(x=rate.daily)) + geom_histogram(bins=30) + xlab('Daily rate') + ylab('Freqüència')
hist07 <- ggplot(data=ds, aes(x=vehicle.year)) + geom_histogram(bins=13) + xlab('Vehicle Year') + ylab('Freqüència')

grid.arrange(hist01, hist02, hist03, hist04, nrow = 2, ncol = 2)
grid.arrange(hist05, hist06, hist07, nrow = 2, ncol = 2)
```

A partir de les visualitzacions anteriors podem fer les següents apreciacions:

* **rating:** Histograma unimodal amb cua a la dreta on podem observar que la gran majoria de vehicles reben valoracions elevades, en concret la puntuació màxima (5). A més s'observa que la presència de vehicles amb baixa puntuació és insignificant.
* **renterTripsTaken:** Histograma unimodal amb cua a l'esquerra, la qual cosa ens indica que els vehicles se solen llogar poques vegades, per sota de 100 vegades. I amb una mitjana de 33.48 lloguers.
* **reviewCount:** Histograma unimodal amb cua a l'esquerra, la qual cosa ens indica que els vehicles solen rebre poques valoracions, per sota de 100 vegades. I amb una mitjana de 28.45 valoracions.
* **location.latitude:** Histograma amb un distribució bastant normal. La qual cosa ens fa pensar que gran part dels vehicles es localitzen en una mateixa latitud, coordenada geogràfica (latitud) en què es troba el vehicle.
* **location.longitude:** Histograma bimodal, amb un pic prop de -120 i un altre pic prop de -80, de nou podem dir que la zona on s'estudia el lloguer de vehicles també queda bastant acotada horitzontalment, coordenada geogràfica (longitud) en què es troba el vehicle.
* **rate.daily:**  Histograma unimodal amb cua a l'esquerra, la qual cosa ens indica que els vehicles se solen llogar per menys de 500 dòlars/dia. Amb un lloguer mitjà de 93.69 dòlars/dia, un lloguer mínim de 20 dòlars/dia i un lloguer màxim de 1500 dòlars/dia.
* **vehicle.year:** Histograma unimodal amb cua a l'esquerra, la qual cosa ens indica que els vehicles de lloguer no solen ser gaire antics. Sent la mitja de 5 anys, el vehicle més antic del 1955 i el vehicle més nou del 2020.

Un altre de les visualitzacions que sol ser de força utilitat per analitzar els jocs de dades són els diagrames de caixes, amb aquests podem observar la dispersió de les dades. A continuació visualitzarem els diagrames de caixes dels atributs numèrics.

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Calculem diagrames de caixa de les variables numèriques
box01 <-ggplot(ds, aes(y=rating)) + geom_boxplot()
box02 <-ggplot(ds, aes(y=renterTripsTaken)) + geom_boxplot()
box03 <-ggplot(ds, aes(y=reviewCount)) + geom_boxplot()
box04 <-ggplot(ds, aes(y=location.latitude)) + geom_boxplot()
box05 <-ggplot(ds, aes(y=location.longitude)) + geom_boxplot()
box06 <-ggplot(ds, aes(y=rate.daily)) + geom_boxplot()
box07 <-ggplot(ds, aes(y=vehicle.year)) + geom_boxplot()

grid.arrange(box01, box02, box03, box04,  nrow = 2, ncol = 2)

grid.arrange(box05, box06, box07, nrow = 2, ncol = 2)
```

A continuació podem veure un detall dels possibles valors extrems.

```{r echo=TRUE, message=FALSE, warning=FALSE}
n <- length(ds$rating)

n - boxplot.stats(ds$rating)$n

n - boxplot.stats(ds$renterTripsTaken)$n

n - boxplot.stats(ds$reviewCount)$n

n - boxplot.stats(ds$location.latitude)$n

n - boxplot.stats(ds$location.longitude)$n

n - boxplot.stats(ds$rate.daily)$n

n- boxplot.stats(ds$vehicle.year)$n
```

A partir del resultats anteriors podem dir que la única variable que presenta valors extrems és les valoracions *'rating'*. En concret tenim 501 observacions que s'alluyen molt dels valors esperats per aquesta variable.  

\newpage
#### Anàlisi dels atributs categòrics
\hfill\break
Continuem visualitzant les distribucions dels valors de les variables categòriques

**Revisem la variable fuelType**

```{r echo=TRUE, message=FALSE, warning=FALSE, fig.width = 4, fig.height=2}
ggplot(data=ds,aes(x=fuelType)) + geom_bar() + ylab("nombre de vehicles")
```

Podem observar que per la majoria de vehicles el combustible és **GASOLINE**, seguits de lluny pels **ELECTRIC** i després pels **HYBRID**. Finalment els **DIESEL** son residuals i queda un subgrup sense etiquetar que el tractarem tot seguit.

Fem un petit tractament de valors Nuls. Aquest el realitzem calculant quin és el valor més freqüent de combustible i substituint els valors nuls per aquest.

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Obtenim el valor més freqüent
most_freq_fuelType <- names(which.max(table(ds$fuelType)))

most_freq_fuelType

# Prenem el valor més freqüent per als valors buits
ds$fuelType[ds$fuelType == ""] = most_freq_fuelType
```

Grafiquem de nou **fuelType**

```{r echo=TRUE, message=FALSE, warning=FALSE, fig.width = 4, fig.height=2}
ggplot(data=ds,aes(x=fuelType)) + geom_bar() + ylab("nombre de vehicles")
```

\newpage
**Revisem la variable location.city**

```{r echo=TRUE, message=FALSE, warning=FALSE}
ggplot(data=ds,aes(x=location.city))+geom_bar() + ylab("nombre de vehicles")
```

Veiem que hi ha tantes categories que és impossible revisar acuradament la gràfica. Llavors optem per graficar només les 30 categories més comuns.

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Seleccionem les dades
location.city_ordered <- sort(table(ds$location.city),decreasing = TRUE)

# Creem la visualització
par(las=2, cex=0.5, mar=c(8,4,4,2))
barplot(location.city_ordered[0:30], main="Nombre de vehicles segons location.city", ylab="Nombre de vehicles") 
```

\newpage
**Revisem la variable location.state**

```{r echo=TRUE, message=FALSE, warning=FALSE, fig.width = 6, fig.height=3}
ggplot(data=ds, aes(x=location.state)) + geom_bar() + theme(axis.text.x = element_text(angle = 90, vjust = 0.1, hjust = 0.1)) + ylab("Nombre de vehicles")
```

Veiem que entre les categories destaquen **CA**, **FL** i **TX**.

Ens proposem afegir un atribut continu, al qual mitjançant la població dels estats, es pugui obviar l'abreviatura categorica dels estats. Ens descarreguem les dades del cens dels estats unit des de: https://www.census.gov/data/datasets/time-series/demo/popest/2010s-state-total.html
i simplifiquem la taula descarregada en un csv que carreguem a continuació.


```{r echo=TRUE, message=FALSE, warning=FALSE}
# Carreguem la taula de població per estat
sp <- read.csv('../data/state-population.csv', stringsAsFactors = FALSE, header = TRUE, sep=',', strip.white = TRUE)

# Creem una nova variable on hi introduim la població de l'estat on es troba el vehicle
ds$population <- ds$location.state

# Assignem la població segons l'estat en el que es troba
for (i in sp$state){
  ds$population[ds$population == i] = sp$Census[sp$state == i]
} 

# convertim la nova variable en numèrica
ds$population <- as.numeric(ds$population)
```

Podem aprofitar per a calcular els diagrames d'aquesta nova variable numèrica.

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Calculem diagrames de caixa i de punts de la nova variable numèrica
ggplot(ds, aes(y=population)) + geom_boxplot()
ggplot(data=ds, aes(x=population)) + geom_histogram(bins=15) + xlab('Population') + ylab('Frequency')
```

\newpage
**Revisem la variable airportcity**

```{r echo=TRUE, message=FALSE, warning=FALSE}
ggplot(data=ds,
       aes(x=airportcity)) + 
  geom_bar() +
  theme(axis.text.x = element_text(angle = 90,
                                   vjust = 0.1,
                                   hjust = 0.1)) +
  ylab("Nombre de vehicles")
```

Tornem a trobar-nos que hi ha massa categories per a fer una visualització cómode. Llavors optem per graficar només les 30 categories més comuns.

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Seleccionem les dades
airportcity_ordered <- sort(table(ds$airportcity),decreasing = TRUE)
# Creem la visualització
par(las=2, cex=0.5, mar=c(8,4,4,2))
barplot(airportcity_ordered[0:30], 
        main="Nº de vehicles segons l'aeroport més proper", 
        ylab="Nombre de vehicles") 
```

**Revisem la variable vehicle.make**

```{r echo=TRUE, message=FALSE, warning=FALSE}
ggplot(data=ds,
       aes(x=vehicle.make)) +
  geom_bar() + 
  theme(axis.text.x = element_text(angle = 90,vjust = 0.1,hjust = 0.1)) + 
  ylab("nombre de vehicles")
```

Aquí ens trobem al límit del que sería una visualització raonable, i veiem que hi ha categories repetides ja que es troben en algún cas mal escrites (per falta de lletres majúscules principalment). 

Per tant realitzem una primera correcció de les categories per a continuació reproduir de nou la visualització.

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Correcció de les marques de vehicles, diferències tipogràfiques
ds$vehicle.make[ds$vehicle.make == "Alfa-romeo"] = "Alfa Romeo"
ds$vehicle.make[ds$vehicle.make == "Mercedes-benz"] = "Mercedes-Benz"
ds$vehicle.make[ds$vehicle.make == "Infiniti"] = "Infinitti"
ds$vehicle.make[ds$vehicle.make == "INFINITI"] = "Infinitti"

ds$vehicle.make <- droplevels.factor(ds$vehicle.make)

ggplot(data=ds,
       aes(x=vehicle.make)) +
  geom_bar() + 
  theme(axis.text.x = element_text(angle = 90,
                                   vjust = 0.1,
                                   hjust = 0.1)) + 
  ylab("nombre de vehicles")
```

A la vista de les dades es pot observar que *TESLA* i *TOYOTA* son les marques més freqüents, seguides de *BMW*, *CHEVROLET*, *FORD* i *Mercedes-Benz*.

Ens trobem que igualment hi ha un nombre molt elevat de categories per aquesta variable (51 concretament) quan de fet, tot el joc de dades amb prou feines arriba a les 6000 observacions. Llavors ens plantegem crear una nova variable **rang** agrupant les marques en 3 grups segons la gamma ("average", "high" o "luxury"):

* average: 'FIAT', 'Ford', 'Honda', 'Hyundai', 'Jeep', 'Kia', 'Land Rover', 'Mazda', 'Mitsubishi', 'Nissan', 'Polaris', 'Pontiac', 'Saturn', 'Scion', 'Suzuki', 'Toyota', 'Volkswagen', 'Volvo'.

* high: 'Alfa Romeo', 'Audi', 'BMW', 'Chevrolet', 'Chrysler', 'Dodge', 'GMC', 'HUMMER', 'Mercedes-Benz', 'Tesla', 'MINI', 'Ram', 'Saab', 'smart', 'Subaru'.

* luxury: 'Acura', 'Aston Martin', 'Bentley', 'Buick', 'Cadillac', 'Ferrari', 'Genesis', 'Infinitti', 'Jagguar', 'Lamborghini', 'Lexus', 'Lincoln', 'Lotus', 'Maserati', 'McLaren', 'Mercury', 'Porsche', 'Rolls Royce'.

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Creem vectors per cada categoria de la nova variables
average = c('FIAT', 'Ford', 'Honda', 'Hyundai', 'Jeep', 'Kia', 'Land Rover', 'Mazda', 'Mitsubishi', 'Nissan', 'Polaris', 'Pontiac', 'Saturn', 'Scion', 'Suzuki', 'Toyota', 'Volkswagen', 'Volvo')
high = c('Alfa Romeo', 'Audi', 'BMW', 'Chevrolet', 'Chrysler', 'Dodge', 'GMC', 'HUMMER', 'Mercedes-Benz', 'Tesla', 'MINI', 'Ram', 'Saab', 'smart', 'Subaru')
luxury = c('Acura', 'Aston Martin', 'Bentley', 'Buick', 'Cadillac', 'Ferrari', 'Genesis', 'Infinitti', 'Jaguar', 'Lamborghini', 'Lexus', 'Lincoln', 'Lotus', 'Maserati', 'McLaren', 'Mercury', 'Porsche', 'Rolls Royce')

# Creem i assignem la nova variable; 
ds$range[is.element(ds$vehicle.make,average)] = "average"
ds$range[is.element(ds$vehicle.make,high)] = "high"
ds$range[is.element(ds$vehicle.make,luxury)] = "luxury"

# Indiquem a R que es tracta de una variable categòrica
ds$range <- droplevels.factor(ds$range)
```

Visualitzem la nova variable categòrica

```{r echo=TRUE, message=FALSE, warning=FALSE}
ggplot(data=ds, aes(x=range)) + geom_bar() + theme(axis.text.x = element_text(angle = 90, vjust = 0.1, hjust = 0.1)) + ylab("nombre de vehicles")
```


**Revisem la variable vehicle.model**

```{r echo=TRUE, message=FALSE, warning=FALSE}
ggplot(data=ds,
       aes(x=vehicle.model))+
  geom_bar() + 
  theme(axis.text.x = element_text(angle = 90,
                                   vjust = 0.1,
                                   hjust = 0.1)) + 
  ylab("nombre de vehicles")
```

Tornem a trobar-nos que hi ha massa categories per a fer una visualització cómode. Llavors optem per graficar només les 30 categories més comuns.

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Seleccionem les dades
vehicle.model_ordered <- sort(table(ds$vehicle.model),decreasing = TRUE)

# Creem la visualització
par(las=2, cex=0.5, mar=c(8,4,4,2))
barplot(vehicle.model_ordered[0:30], main="Nombre de vehicles segons el model", ylab="Nombre de vehicles") 
```

**Revisem la variable vehicle.type**

```{r echo=TRUE, message=FALSE, warning=FALSE}
ggplot(data=ds,
       aes(x=vehicle.type)) +
  geom_bar() + 
  theme(axis.text.x = element_text(angle = 90,
                                   vjust = 0.1,
                                   hjust = 0.1)) + 
  ylab("nombre de vehicles")
```

S'observa que la categoria **car** seguida de lluny per **SUV** són les més comuns, sent la resta (**minivan**, **truck** i **van**) gairebé residuals.

\newpage
**Visualització multivariant de les dades categòriques**

Usem el gràfic de mosaic per visualitzar la convinació entre **fuelType** i **vehicle.type**


```{r echo=TRUE, message=FALSE, warning=FALSE}
mosaic(ds$fuelType ~ ds$vehicle.type, gp_labels = gpar(fontsize = 8), las = 2, cex.axis = 2, rot_labels=c(90,90,0,0), shade=TRUE)
```

Aprofitem per viisuallitzar la convinació de les variables anteriors i **range**

```{r echo=TRUE, message=FALSE, warning=FALSE}
mosaic(ds$fuelType ~ ds$range + ds$vehicle.type, gp_labels = gpar(fontsize = 8), las = 2, cex.axis = 2, rot_labels=c(90,0,0,00), shade=TRUE)
```

Gràcies al gràfic de mosaic es pot observar que només hi ha la categoria **HYBRID** en vehicles tipus **car** (en la resta és residual). Per altre banda DESTACA que no hi ha vehicles **ELECTRIC** per **van** ni **minivan** les quals son gairebé totalment **GASOLINE**.

Alternativament visualitzem les mateixes dades amb un ballonplot

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Preparem les dades
taula = as.data.frame(table(ds$fuelType, ds$vehicle.type))

# Visualitza el Ballonplot
ggballoonplot(taula, fill = "value") + scale_fill_viridis_c(option = "C")
```



\newpage
### Zeros i atributs buits

Ara farem el tractament dels valors buits i convertirem les variables discretes a factors.

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Estadístiques de valors buits, validem si hi ha valors buits
colSums(is.na(ds))
```

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Estadístiques de valors buits, validem si hi ha valors buits
colSums(ds=="")
```

Es pot veure que queda 1 variable amb valors buits (rating). Anem a calcular doncs quin és el seu valor més freqüent 

```{r echo=TRUE, message=FALSE, warning=FALSE}
most_freq_rating <- names(which.max(table(ds$rating)))

most_freq_rating
```

Assignem el valor més freqüent als valors buits i comprovem que després del tractament no hi hagi valors buits

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Prenem el valor més freqüent per als valors buits
ds$rating[is.na(ds$rating)] = as.numeric(most_freq_rating)

# Visualitzem de nou si hi ha valors buits
colSums(is.na(ds))
colSums(ds=="")
```


### Valors extrems (Outliers)

Després del tractament dels valors buits examinem de nou els possibles valors extrems.

```{r echo=TRUE, message=FALSE, warning=FALSE}
n <- length(ds$rating)

n - boxplot.stats(ds$rating)$n
```

Podem veure com el joc de dades ja no presenta valors extrems. I que els valors extrems de la variable *'rating'* es corresponien amb dades buides.

### Discretització de variables

Ara examinarem per quines variables tindria sentit realitzar una discretització.

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Per a quines variables tindria sentit un procés de discretizació?
apply(ds, 2, function(x) length(unique(x)))
```

Per aquelles variables amb pocs valors possibles podem realitzar una discretització. Per això convertim les variables discretes a factors d'*R*.

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Convertim les variables discretes a factors
ds[,categorical_features_names] <- lapply(ds[,categorical_features_names] , factor)

# Mostrem el resultat
str(ds)
```



### Transformació d'atributs

A continuació realitzarem algunes transformacions sobre alguns atributs, amb la finalitat de generar diferents punts de vista de les dades.

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Discretització amb intevals prefixats, de les valoracions
table(discretize(ds$rating, method = "fixed", c(0, 4.5, Inf), labels = c('Bad', 'Good')))

hist(ds$rating, breaks = 20, main = "Discretització amb intervals prefixats", xlab = "Valoració")
cuts_rating <- discretize(ds$rating, method = "fixed",c(0, 4.5, Inf), onlycuts = TRUE)
abline(v = cuts_rating, col = "red")
```

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Discretització amb intevals prefixats, de les valoracions
ds['rating.discret'] <- discretize(ds$rating, method = "fixed", breaks = c(0, 4.5, Inf), labels = c('Bad', 'Good'))

ds$rating.discret = as.factor(ds$rating.discret)

# Calculem gràfic de barres
ggplot(data=ds, aes(x = rating.discret)) + geom_bar(aes(y = (..count..)/sum(..count..))) + geom_text(aes(y = ((..count..)/sum(..count..)), label = scales::percent((..count..)/sum(..count..))), stat = "count", vjust = -0.5) + scale_y_continuous(labels = scales::percent, limits = c(0,1)) + xlab('Valoració') + ylab("Percentatge")
```

La variable **population** per exemple, podria ser tallada amb els 4 quartils que té, per crear 4 categories diferenciant els vehicles ubicats en estats amb més o menys població. Així creem **population.discr**

```{r echo=TRUE, message=FALSE, warning=FALSE}
summary(ds$population)
```
```{r echo=TRUE, message=FALSE, warning=FALSE}
ds['population.discr'] <- discretize(ds$population, method = "fixed",c(601722, 5029197, 9687653, 25145561, 37253957), labels = c("low populated", "medium-low populated", "medium-high populated", "highly populated"))

# Calculem gràfic de barres
ggplot(data=ds, aes(x = population.discr)) + 
  geom_bar(aes(y = (..count..)/sum(..count..))) + 
  geom_text(aes(y = ((..count..)/sum(..count..)), label = scales::percent((..count..)/sum(..count..))), stat = "count", vjust = -0.5) + scale_y_continuous(labels = scales::percent, limits = c(0,1)) + 
  xlab('Població a l entorn') + 
  ylab("Percentatge")
```
Veiem que les 4 categories tenen pràcticament assignat un tamany igual de mostra.

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Factoritzem la nova variable finalment

ds$population.discr = as.factor(ds$population.discr)

```

### Creació de nous indicadors

Un altre dels passos interessant en l'anàlisi d'un joc de dades és la generació de nous atributs a partir dels existents. 

**Indicador: age**

Creem un nou indicador o atribut on emmagatzemem l'antiguitat del vehicle.

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Antiguitat del vehicle
ds['age'] <- as.integer(format(Sys.Date(), "%Y")) - ds$vehicle.year

# Calculem gràfic de barres de la nova variable
ggplot(data=ds, aes(x = age)) + 
  geom_bar(aes(y = (..count..)/sum(..count..))) + 
  scale_x_continuous(breaks = round(seq(min(ds$age), max(ds$age), by = 5), 1)) + 
  xlab('Age') + 
  ylab("Percentatge")
```

**Indicador: rent**

Creem un altre indicador o atribut nou on emmagatzemem si el vehicle va ser llogat o no.

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Vehicle llogat/no llogat
ds['rent'] <- ifelse(ds['renterTripsTaken'] > 0, 1, 0)
ds$rent <- as.factor(ds$rent)
levels(ds$rent) <- c("Not","Yes")

# Calculem gràfic de barres de la variable objectiu
ggplot(data=ds, aes(x = rent)) + geom_bar(aes(y = (..count..)/sum(..count..))) + geom_text(aes(y = ((..count..)/sum(..count..)), label = scales::percent((..count..)/sum(..count..))), stat = "count", vjust = -0.5) + scale_y_continuous(labels = scales::percent, limits = c(0,1)) + xlab('Rent') + ylab("Percentatge")
```

**Indicador: income**

Creem un altre indicador o atribut nou on emmagatzemem els ingressos anuals que va aportar el vehicle.

Per crear aquesta variable **income** (ingressos anuals mitjans), s'assumeix el següent:

- **renterTripsTaken** és equivalent al nombre de dies que el cotxe ha estat llogat i que per tant es poden aproximar els ingressos totals aportats pel vehicle com a resultat del producte entre **renterTripsTaken** i **rate.daily**.

- s'assumeix que **age** representa tots els anys de vida del cotxe, per tant si es vol calcular els ingressos anuals cal repartir-los entre age

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Ingressos anuals vehicle

# En primer lloc establim que la edat mínima amb la que treballem és d'un any
# per tal d'evitar divisors de "0"
edat = ds$age
edat[edat == 0] = 1

ds['income'] <- ds$rate.daily * ds$renterTripsTaken / edat

# Calculem gràfic de barres de la nova variable
ggplot(data=ds, aes(x=ds$income)) + geom_histogram(breaks=seq(0, 1000, by=10), alpha = 1) + labs(title="Histogram for Income", x="Income", y="Count") + xlim(c(0,1000)) + ylim(c(0,500))

ggplot(data=ds, aes(x=ds$income)) + 
  geom_histogram(breaks=seq(0, 10000, by=100), alpha = 1) + 
  labs(title="Histogram for Income", x="Income", y="Count") + 
  xlim(c(0,10000)) + 
  ylim(c(0,2000))

```

**Indicador: frequency**

Creem un altre indicador o atribut nou on emmagatzemem la freqüència amb la que es va llogar el vehicle (**frequency**).

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Freqüència d'us del vehicle (vegades a l'any)

# En primer lloc establim que la edat mínima amb la que treballem és d'un any
# per tal d'evitar divisors de "0"
edat = ds$age
edat[edat == 0] = 1

ds['frequency'] <- ds$renterTripsTaken / edat

# Calculem gràfic de barres de la nova variable
ggplot(data=ds, aes(x=ds$frequency)) + 
  geom_histogram(breaks=seq(0, 1000, by=10), 
                 alpha = 1) + 
  labs(title="Histogram for frequency", x="frequency", y="Count")

ggplot(data=ds, aes(x=ds$frequency)) + 
  geom_histogram(breaks=seq(0, 150, by=1.5), alpha = 1) + 
  labs(title="Histogram for frequency", x="frequency", y="Count") + 
  xlim(c(0,150)) + 
  ylim(c(0,200))

```


### Exportació de les dades preprocesades

Una vegada que hem realitzat sobre el conjunt de dades inicial els procediments de preprocessament integració, validació i neteja, procedim a guardar aquest nou joc de dades en un fitxer anomenat CarRentalDataV1_Clean.csv.

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Exportació de les dades preprocessades a un fitxer .CSV
write.csv(ds, '../data/CarRentalDataV1_Clean.csv')
```




## Anàlisi de les dades

La gran majoria dels atributs presents en el conjunt de dades es corresponen amb característiques dels diversos vehicles de lloguer o de la seva ubicació, per tant serà convenient tenir-los en consideració durant la realització de les anàlisis. No obstant això, podem prescindir de tres atributs, l'estat (location.country; que sempre és *US*) i les dues coordenades geogràfiques (location.latitude i location.longitude) ja que la informació que ens aporten aquestes variables ja es troba implicita en la resta d'atributs de localització  i, per tant, són menys rellevants a l' hora de resoldre el nostre problema.


### Selecció dels grups de dades a analitzar


```{r echo=TRUE, message=FALSE, warning=FALSE}
# Eliminem location.country i les coordenades geogràfiques
ds <- subset(ds, select=-c(location.latitude,location.longitude, location.country))

categorical_features_names = c('fuelType', 'location.city', 'location.state', 'owner.id', 'vehicle.make', 'vehicle.model', 'vehicle.type', 'airportcity', 'range', 'population.discr') 

numeric_features_names = c('rating', 'renterTripsTaken', 'reviewCount', 'rate.daily', 'age', 'income', 'frequency', 'population')
```


### Comprobació de la normalitat

Per a la comprovació que els valors que prenen les nostres variables quantitatives provenen d'una població distribuïda normalment, utilitzarem la prova de normalitat d'Anderson-Darling. Per això, es comprova que per cada prova s'obté un *p-valor* superior el nivell de significació prefixat = 0. 05 (Nivell de confiança del 95%). Si això es compleix, llavors es considera que la variable en qüestió segueix una distribució normal.

**Test de normalitat**

```{r echo=TRUE, message=FALSE, warning=FALSE}
alpha = 0.05
col.names = colnames(ds)

for (i in 1:ncol(ds)) {
  if (i == 1) cat("Variables que no presenten una distribució normal:\n")
    if (is.integer(ds[,i]) | is.numeric(ds[,i])) {
      p_val = ad.test(ds[,i])$p.value
      if (p_val < alpha) {
        cat(col.names[i])
        # Format output
        if (i < ncol(ds) - 1) cat(", ")
        if (i %% 3 == 0) cat("\n")
      }
    }
}
```

A partir del resultat anterior podem veure com que cap dels atributs quantitaius presenta una distribució normal. Tot i així ens centrarem ara un moment el la variable depenent o variable objectiu en el nostre estudi, el preu diari del vehicle.

Si observem els valors mínim, mitjà i màxim veiem clarament que no és una variable amb distribució normal. Però en la majoria de models numèrics d'aprenentatge automàtic, necessitarem que les variables segueixin la distribució normal. Per això podem emprar visualitzacions de les dades per analitzar la normalitat. Concretament, el gràfic Q-Q, on la Q denota quantil, és un tipus de visualització que s'utilitza per a diagnosticar la desviació de les dades de la mostra en relació amb una població normal.

```{r echo=TRUE, message=FALSE, warning=FALSE}
qqnorm(ds$rate.daily, ylab="Daily Rate", xlab="Theorical Quantiles", main="Normal Q-Q Plot") 
qqline(ds$rate.daily)
```

Quan tenim una variable que no és normal, una de les transformacions clàssiques que pot funcionar és aplicar el logaritme a la variable.

Alternativament podem usar la funció *BoxCox* la qual ens ajuda a seleccionar la transformació óptima de la variable per a que s'acabi distribuint de forma "normal".

**Normalització de Daily Rate (Preu)**

```{r echo=TRUE, message=FALSE, warning=FALSE}
ds$rate.daily <- log(ds$rate.daily)

ggplot(ds, aes(x = rate.daily)) +  geom_histogram() +  ylab("Nombre de vehicles") + xlab("Preu de venda")
```

Veiem com ara sí que té forma normal. Ho comprovem amb el Q-Q plot per confirmar-ho.

```{r echo=TRUE, message=FALSE, warning=FALSE}
qqnorm(ds$rate.daily, ylab="Daily Rate normalized", xlab="Theorical Quantiles", main="Normal Q-Q Plot") 
qqline(ds$rate.daily)
```

**Normalització de Rating (Puntuació)**

```{r echo=TRUE, message=FALSE, warning=FALSE}
lambda_optima <- BoxCoxLambda(ds$rating)
ds$rating_norm <- BoxCox(ds$rating, lambda = lambda_optima)

ggplot(ds, aes(x = rating)) +  geom_histogram() +  ylab("Nombre de cotxes") + xlab("Puntuació")
ggplot(ds, aes(x = rating_norm)) +  geom_histogram() +  ylab("Nombre de cotxes") + xlab("Puntuació normalitzada")
```

Veiem de forma evident que, tot i amb la conversió, no s'obté forma de distribució normal. 

**Normalització de Renter Trips Taken (Nombre de lloguers realitzats)**

```{r echo=TRUE, message=FALSE, warning=FALSE}
lambda_optima <- BoxCoxLambda(ds$renterTripsTaken)
ds$renterTripsTaken_norm <- BoxCox(ds$renterTripsTaken, lambda = lambda_optima)

ggplot(ds, aes(x = renterTripsTaken)) +  geom_histogram() +  ylab("Nombre de cotxes") + xlab("Nombre de lloguers realitzats")
ggplot(ds, aes(x = renterTripsTaken_norm)) +  geom_histogram() +  ylab("Nombre de cotxes") + xlab("Nombre normalitzat de lloguers realitzats")
```

Veiem que, tot i amb la conversió, no s'obté forma de distribució normal ja que queden un grup significatiu de valors aïllats. 

**Normalització de reviewCount (Nombre de comentaris)**

```{r echo=TRUE, message=FALSE, warning=FALSE}
lambda_optima <- BoxCoxLambda(ds$reviewCount)
ds$reviewCount_norm <- BoxCox(ds$reviewCount, lambda = lambda_optima)

ggplot(ds, aes(x = reviewCount)) +  geom_histogram() +  ylab("Nombre de cotxes") + xlab("Nombre de comentaris")
ggplot(ds, aes(x = reviewCount_norm)) +  geom_histogram() +  ylab("Nombre de cotxes") + xlab("Nombre normalitzat de comentaris ")
```

Veiem que, tot i amb la conversió, no s'obté forma de distribució normal ja que queden un grup significatiu de valors aïllats. 


**Normalització de vehicle.year (Any del cotxe)**

```{r echo=TRUE, message=FALSE, warning=FALSE}
lambda_optima <- BoxCoxLambda(ds$vehicle.year)
ds$vehicle.year_norm <- BoxCox(ds$vehicle.year, lambda = lambda_optima)

ggplot(ds, aes(x = vehicle.year)) +  geom_histogram() +  ylab("Nombre de cotxes") + xlab("Any del cotxe")
ggplot(ds, aes(x = vehicle.year_norm)) +  geom_histogram() +  ylab("Nombre de cotxes") + xlab("Any del cotxe normalitzat")
```

Veiem que, tot i amb la conversió, no s'obté forma de distribució normal. 

**Normalització de Income (Ingressos anuals del cotxe)**

```{r echo=TRUE, message=FALSE, warning=FALSE}
lambda_optima <- BoxCoxLambda(ds$income)
ds$income_norm <- BoxCox(ds$income, lambda = lambda_optima)

ggplot(ds, aes(x = income)) +  geom_histogram() +  ylab("Nombre de cotxes") + xlab("Ingressos anuals del cotxe")
ggplot(ds, aes(x = income_norm)) +  geom_histogram() +  ylab("Nombre de cotxes") + xlab("Ingressos anuals normalitzats del cotxe")
```

Veiem que, tot i amb la conversió, no s'obté forma de distribució normal ja que queden un grup significatiu de valors aïllats. 

**Normalització de Frecuency (freqüència anual d'us del cotxe)**

```{r echo=TRUE, message=FALSE, warning=FALSE}
lambda_optima <- BoxCoxLambda(ds$frequency)
ds$frequency_norm <- BoxCox(ds$frequency, lambda = lambda_optima)

ggplot(ds, aes(x = frequency)) +  geom_histogram() +  ylab("Nombre de cotxes") + xlab("Freqüència anual d'us del cotxe")
ggplot(ds, aes(x = frequency_norm)) +  geom_histogram() +  ylab("Nombre de cotxes") + xlab("Freqüència anual normalitzada d'us del cotxe")
```

Veiem que, tot i amb la conversió, no s'obté forma de distribució normal ja que queden un grup significatiu de valors aïllats. 

**Neteja de noves variables creades que no han tingut èxit en la normalització**

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Eliminem location.country i les coordenades geogràfiques
ds <- subset(ds, select=-c(rating_norm, renterTripsTaken_norm, reviewCount_norm, vehicle.year_norm, income_norm, frequency_norm))

numeric_features_names = c('rating', 'renterTripsTaken', 'reviewCount', 'rate.daily', 'age', 'income', 'frequency', 'population')
```

\newpage
**Anàlisi multivariant** 

Per analitzar un conjunt de dades necessitem tenir en compte més d'una variable alhora. L'anàlisi bivariant permet identificar les relacions entre dues variables, i fins quina manera una pot predir l'altra.

En aquest cas podem veure quina és la relació entre el preu diari del lloguer i el nombre de vegades que s'ha llogat el vehicle amb un scatter plot o diagrama de punts.

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Relació entre el preu diari del lloguer i el nombre de vegades que s'ha llogat el vehicle
ggplot(ds, aes(x=renterTripsTaken, y=rate.daily)) + geom_point()
```

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Relació entre el preu diari del lloguer i ela freqüencia amb que s'ha llogat un vehicle
ggplot(ds, aes(x=frequency, y=rate.daily)) + geom_point()
```

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Relació entre e l'edat i el nombre de vegades que s'ha llogat el vehicle
ggplot(ds, aes(x=age, y=rate.daily)) + geom_point()
```

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Relació entre la població de l'estat i el nombre de vegades que s'ha llogat el vehicle
ggplot(ds, aes(x=population, y=rate.daily)) + geom_point()
```

En el cas d'una variable categòrica com el tipus de combustible o la marca del vehicle, podem visualitzar la relació amb un boxplot o diagrama de caixes.

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Relació entre el preu diari del lloguer i el tipus de combustible
ggplot(ds, aes(x=fuelType, y=rate.daily, fill=fuelType)) + geom_boxplot(alpha=0.1) + stat_summary(fun.y=mean)
```

A partir del gràfic anterior podem observar com el tipus de combustible sembla que influeix al preu diari de lloguer. Essent el lloguer més car pels vehicles elèctrics i el més econòmic el dels vehicles híbrids. Mentre que el preu dels vehicles diesel i gasolina és similar.

```{r echo=TRUE, message=FALSE, warning=FALSE, fig.width = 6}
# Relació entre el preu diari del lloguer i l'estat on es localitza el vehicle
ggplot(ds, aes(x=location.state, y=rate.daily, fill=location.state)) + geom_boxplot(alpha=0.1) + stat_summary(fun.y=mean) + theme(axis.text.x = element_text(angle = 90,vjust = 0.1,hjust = 0.1)) + theme(legend.position = "none")
```

A partir del gràfic anterior podem observar com l'estat on es localitza el vehicle sembla que influeix al preu diari de lloguer. Essent el lloguer més car pels vehicles de l'estat d'NM.

```{r echo=TRUE, message=FALSE, warning=FALSE, fig.width = 6}
# Relació entre el preu diari del lloguer i la població que té l'estat on es troba el cotxe (discret)
ggplot(ds, aes(x=population.discr, y=rate.daily, fill=population.discr)) + geom_boxplot(alpha=0.1) + stat_summary(fun.y=mean) + theme(axis.text.x = element_text(angle = 90,vjust = 0.1,hjust = 0.1)) + theme(legend.position = "none")
```

A partir del gràfic anterior podem observar com l'estat on es localitza el vehicle sembla no influeix en el preu diari del lloguer.

```{r echo=TRUE, message=FALSE, warning=FALSE, fig.width = 6}
# Relació entre el renterTripstaken i la població que té l'estat on es troba el cotxe (discret)
ggplot(ds, aes(x=population.discr, y=renterTripsTaken, fill=population.discr)) + geom_boxplot(alpha=0.1) + stat_summary(fun.y=mean) + theme(axis.text.x = element_text(angle = 90,vjust = 0.1,hjust = 0.1)) + theme(legend.position = "none")
```


```{r echo=TRUE, message=FALSE, warning=FALSE, fig.width = 6}
# Relació entre el preu diari del lloguer i la marca del vehicle
ggplot(ds, aes(x=vehicle.make, y=rate.daily, fill=vehicle.make)) + geom_boxplot(alpha=0.1) + stat_summary(fun.y=mean) + theme(axis.text.x = element_text(angle = 90,vjust = 0.1,hjust = 0.1)) + theme(legend.position = "none")
```

A partir del gràfic anterior podem observar com la marca del vehicle sembla que influeix al preu diari de lloguer. Essent el lloguer més car pels vehicles d'alta gama, com ja podiem intuir, on destaca *Rolls Royce, Lamborgini, Aston Martin i Ferrari*.

```{r echo=TRUE, message=FALSE, warning=FALSE, fig.width = 6}
# Relació entre el preu diari del lloguer i la gamma del vehicle
ggplot(ds, aes(x=range, y=rate.daily, fill=range)) + geom_boxplot(alpha=0.1) + stat_summary(fun.y=mean) + theme(axis.text.x = element_text(angle = 90,vjust = 0.1,hjust = 0.1)) + theme(legend.position = "none")
```

```{r echo=TRUE, message=FALSE, warning=FALSE, fig.width = 6}
# Relació entre la freqüencia del lloguer i la gamma del vehicle
ggplot(ds, aes(x=range, y=frequency, fill=range)) + geom_boxplot(alpha=0.1) + stat_summary(fun.y=mean) + theme(axis.text.x = element_text(angle = 90,vjust = 0.1,hjust = 0.1)) + theme(legend.position = "none")
```

```{r echo=TRUE, message=FALSE, warning=FALSE, fig.width = 6}
# Relació entre el preu diari del lloguer, la gamma del vehicle i el lcombustible
ggplot(ds, aes(x=range, y=rate.daily, fill=fuelType)) + geom_boxplot(alpha=0.1) + stat_summary(fun.y=mean) + theme(axis.text.x = element_text(angle = 90,vjust = 0.1,hjust = 0.1)) + theme(legend.position = "none")
```

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Relació entre el preu diari del lloguer i el tipus de vehicle
ggplot(ds, aes(x=vehicle.type, y=rate.daily, fill=vehicle.type)) + geom_boxplot(alpha=0.1) + stat_summary(fun.y=mean)
```


A partir del gràfic anterior podem observar com el tipus del vehicle sembla que influeix al preu diari de lloguer. Essent el lloguer més car per les furgonetes (*van*), i el més econòmic per les mini furgonetes (*minivan*). Mentre que per la resta de tipus de vehicles *car, suv i truck* no s'observa una gran diferència en el preu.

Si volem visualitzar alhora les relacions creuades entre diverses variables, podem fer un pairplot.

Examinem els atributs numèrics envers si el vehicle va se llogat o no.
```{r echo=TRUE, message=FALSE, warning=FALSE, fig.width = 5, fig.height=5}
ggpairs(ds, columns=numeric_features_names, mapping=aes(color=rent), upper = list(continuous = wrap('cor', size = 2)))
```

A partir del pairplot anterior veiem que hi ha un solapament entre totes les funcions de densitat, en funció de si va ser llogat o no el vehicle, amb la qual cosa podem determinar que no hi ha cap atribut numèric que ens permeti identificar si el vehicle va ser llogat o no directament. D'altre banda podem destacar la relació lineal que s'observa entre l'atribut *renderTripsTaken* i *reviewCount*, on tal i com podriem pensar quans més cops es lloga un vehicle més valoracions rep. 

Examinem els atributs numèrics envers la qualificació que va obtenir el vehicle.

```{r echo=TRUE, message=FALSE, warning=FALSE, fig.width = 5, fig.height=5}
ggpairs(ds, columns=numeric_features_names, mapping=aes(color=rating.discret), upper = list(continuous = wrap('cor', size = 2)))
```

A partir del pairplot anterior veiem que hi ha un solapament entre totes les funcions de densitat, en funció de la qualificació obtinguda pel vehicle de lloguer, amb la qual cosa podem determinar que no hi ha cap atribut numèric que ens permeti identificar la puntuació del vehicle directament. D'altre banda també s'observa la relació lineal que hi ha entre l'atribut *renderTripsTaken* i *reviewCount*, on tal i com podriem pensar quans més cops es lloga un vehicle més valoracions rep. 


Finalment, ens interessarà veure quins conjunts de variables estan relacionats entre si. Per això, farem servir tècniques estadístiques d'anàlisi multivariant.

Una de les eines més útils és calcular la matriu de correlació entre les variables. Amb la funció qplot i la correlació de variables, calculada amb la funció cor, podem visualitzar de manera fàcil aquelles variables més correlacionades, que corresponen a una intensitat major de color.

```{r echo=TRUE, message=FALSE, warning=FALSE, fig.width = 6, fig.height=4}
heat <- ds[,numeric_features_names]
qplot(x=Var1, y=Var2, data=melt(cor(heat, use="p")), fill=value, geom="tile") + theme(axis.text.x = element_text(angle = 90)) + coord_fixed()
```

## Test estadístics

### ¿Quines variables quantitatives influeixen més a les valoracions?

En primer lloc, procedim a realitzar una anàlisi de correlació entre les diferents variables per determinar quines d'elles exerceixen una major influència sobre el preu diari del lloguer del vehicle. Per a això, s'utilitzarà el coeficient de correlació de Spearman, ja que hem vist que
tenim dades que no segueixen una distribució normal.

```{r echo=TRUE, message=FALSE, warning=FALSE}
corr_matrix <- matrix(nc = 2, nr = 0)
colnames(corr_matrix) <- c("estimate", "p-value")

# Calcular el coeficiente de correlación para cada variable cuantitativa
# con respecto al campo "precio"
for (i in 1:(ncol(ds) - 1)) {
  if (is.integer(ds[,i]) | is.numeric(ds[,i])) {
    spearman_test = cor.test(ds[,i], ds[,'rate.daily'], method = "spearman")
    corr_coef = spearman_test$estimate
    p_val = spearman_test$p.value
    
    # Add row to matrix
    pair = matrix(ncol = 2, nrow = 1)
    pair[1][1] = corr_coef
    pair[2][1] = p_val
    corr_matrix <- rbind(corr_matrix, pair)
    rownames(corr_matrix)[nrow(corr_matrix)] <- colnames(ds)[i]
  }
}

print(corr_matrix)
```

A partir del resultat obtingut podem identificar quines són les variables més correlacionades amb el preu diari de lloguer en funció de la seva proximitat amb els valors -1 i +1. Tenint en compte això, queda palès com la variable més rellevant en la fixació del preu és l'antigitat del vehicle (age) seguida de les valoracions. La variable **income** obté obviament una elevada correlació no obstant o entrem en valorar-la ja què està creada amb un calcul a partir de la mateixa **rate.daily**

Nota. Per a cada coeficient de correlació es mostra també el seu *p-valor* associat, ja que aquest pot donar informació sobre el pes estadístic de la correlació obtinguda.


### ¿Els cotxes elèctric tenen un preu més elevat que els cotxes de benzina?

Per a avaluar si els cotxes elèctics tenen un preu de lloguer diari més elevat que els cotxes de benzina, podem aplicar un test d’hipòtesis de dues mostres. Tal i com veurem a continuació.

**Hipòtesi nul·la i alternativa**

Comencem amb la definició de la hipòtesi nul·la i de la hipòtesi alternativa.

* Hipòtesi nul·la: $$H_{0}: \mu_{1} = \mu_{2} $$ 

* Hipòtesi alternativa: $$H_{1}: \mu_{1} > \mu_{2} $$ 

A continuació revisem si es compleix l’assumpció de normalitat per a la variable 'rate.daily' i a partir d’això, podrem explicar quin test podem aplicar per al test d’hipòtesis de dues mostres. 

**Test de normalitat**

En primer lloc avaluem l'assumpció de normalitat per a la variable 'rate.daily'

```{r echo=TRUE, message=FALSE, warning=FALSE}
par(mfrow=c(1,3))
x <- ds$rate.daily
qq1 <- qqnorm(x, main = "Normal Q-Q Plot 'Daily rate'")
qqline(x)

x <- ds$rate.daily[ds$fuelType == 'ELECTRIC']
qq2 <- qqnorm(x, main = "Normal Q-Q Plot 'DR - ELECTRIC'")
qqline(x)

x <- ds$rate.daily[ds$fuelType == 'GASOLINE']
qq3 <- qqnorm(x, main = "Normal Q-Q Plot 'DR - GASOLINE'")
qqline(x)
```

En aquest cas, els punts estan pràcticament sobre la línia, i, per tant, es pot assumir normalitat,

Per tant podem dir que totes dues poblacions es distribueixen normalment, però ens faltaria saber, donat que la variància poblacional és desconeguda, si aquestes poblacions presenten variàncies iguals  o variàncies differents.

**Test d'igualtat de variàncies**

Per a aplicar l’estadístic adequat, cal comprovar si les variàncies de les dues poblacions són iguals. Per això, apliquem primer el test d’igualtat de variàncies.

Per això podem realitzar un altre test, tal que:

* Hipòtesi nul·la: $$H_{0}: \sigma^{2}_{1} = \sigma^{2}_{2} $$ 

* Hipòtesi alternativa: $$H_{1}: \sigma^{2}_{1} \neq \sigma^{2}_{2} $$ 

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Obtenim les dades
ELECTRIC <- ds$rate.daily[ds$fuelType == 'ELECTRIC']
GASOLINE <- ds$rate.daily[ds$fuelType == 'GASOLINE']

# Calculem el test d’igualtat de variàncies, amb la funció var.test d'R
var.test(ELECTRIC, GASOLINE)
```

Donat que el valor *p-value* obtingut és menor que el nivell de significació (0.05) podem rebutjar la hipòtesi nul·la i per tant podem dir que la variància de ambdues poblacions és diferent amb un nivell de confiança del 95%.

A partir dels resultats anteriors podem dir que el test a aplicar serà un test d’hipòtesis de dues mostres de poblacions independents amb distribucions normals i variàncies desconegudes i diferents.

**Test de la mitjana de dues mostres independents amb variància desconeguda i diferents**

Arribats aquest punt, amb la funció *t.test* d’R que ens permet realitzar el contrast d’hipòtesis directament, realitzem el test de mitjanes.

```{r echo=TRUE, message=FALSE, warning=FALSE}
# variàncies diferents
t.test( ds$rate.daily[ds$fuelType == 'ELECTRIC'],  ds$rate.daily[ds$fuelType == 'GASOLINE'], alternative="greater", var.equal=FALSE)
```

El valor *p-value* obtingut és menor que el nivell de significació (0.05) i, per tant, podem rebutjar la hipòtesi nul·la d’igualtat de mitjanes de preu de lloguer diari entre els cotxes elèctris i els cotxes de benzina. Per tant podem dir que els cotxes électrics tenen un lloguer més elevat que els de benzina, amb un nivell de confiança del 95%.


### ¿La proporció de furgonetes és més petit que la d'utilitaris?

Ara ens preguntem si la proporció de furgonetes de lloguer és més petit que la d'utilitaris o vehicles convencionals.

**Hipòtesi nul·la i alternativa**

Per tal de donar resposta a la pregunta formulada, comencem amb la definició de la hipòtesi nul·la i de la hipòtesi alternativa.

* Hipòtesi nul·la: $$H_{0}: p = 0.5 $$ 

* Hipòtesi alternativa: $$H_{1}: p_{1} < 0.5 $$ 

En aquest cas específicament, ens preguntem si la proporció de furgonetes és més petita que la d'utilitaris, o el que és el mateix, si la proporció de furgonetes és igual a 0.5.


**Test unilateral d'una mostra sobre la proporció**

A continuació podem realitzar els càlculs pertinents que ens permetin decidir si podem rebutjar la hipòtest nul-la o no.

Podem fer servir, la funció prop.test pròpia d’R que ens permet realitzar directament contrastos d’hipòtesis sobre proporcions.

```{r echo=TRUE, message=FALSE, warning=FALSE}
n <- length(ds$vehicle.type)

prop.test(x=sum(ds$vehicle.type == "van"  | ds$vehicle.type == "minivan"), n=n, p=0.5, alternative="less", correct=FALSE)
```

D'altra banda el *p-valor* és inferior al nivell de significació (*p-value < &alpha;*), per tant podem rebutjar la hipòtesi nul·la.  Això ens permet dir que la proporció de furgonetes és més petita que la d'utilitàris, amb un nivell de confiança del 95%.


### ¿El preu diari del lloguer del vehicle és diferent en funció del tipus de vehicle?

Per tal de donar resposta a aquesta pregunta, realitzarem un contrast de la igualtat de varianza mitjançant un test de *Bartlett* en dues o més poblacions sense la necessitat de que la mida dels grups que comparem sigui la mateixa. 

```{r echo=TRUE, message=FALSE, warning=FALSE}
car <- ds[ds$vehicle.type == "car", "rate.daily"]
minivan <- ds[ds$vehicle.type == "minivan", "rate.daily"]
suv <- ds[ds$vehicle.type == "suv", "rate.daily"]
truck <- ds[ds$vehicle.type == "truck", "rate.daily"]
van <- ds[ds$vehicle.type == "van", "rate.daily"]

bartlett.test(list(car, minivan, suv, truck, van))
```

El *p-valor* és inferior al nivell de significació (*p-value < &alpha;*), per tant podem rebutjar la hipòtesi nul·la.  Això ens permet dir que el preu diari del lloguer del vehicle depén del tipus de vehicle, amb un nivell de confiança del 95%.

Podem veure que tenim cinc grups diferents (5 categories de vehicles) que volem comparar. A partir del test realitzat hi ha evidències de que la varianza no és la mateixa en tots el grups. Fet que ja podiem intuir al diagrama de caixes o boxplot on mostravem l'atribut 'rate.daily' envers 'vehicle.type'.

### ¿El preu diari del lloguer del vehicle és diferent en funció del tipus de combustible?

Per tal de donar resposta a aquesta pregunta, realitzarem un contrast de la igualtat de varianza mitjançant un test de *Bartlett* en dues o més poblacions sense la necessitat de que la mida dels grups que comparem sigui la mateixa.

```{r echo=TRUE, message=FALSE, warning=FALSE}
diesel <- ds[ds$vehicle.type == "car", "rate.daily"]
electric <- ds[ds$vehicle.type == "minivan", "rate.daily"]
gasoline <- ds[ds$vehicle.type == "suv", "rate.daily"]
hybrid <- ds[ds$vehicle.type == "truck", "rate.daily"]

bartlett.test(list(diesel, electric, gasoline, hybrid))
```

El *p-valor* és inferior al nivell de significació (*p-value < &alpha;*), per tant podem rebutjar la hipòtesi nul·la.  Això ens permet dir que el preu diari del lloguer del vehicle depén del tipus de combustible, amb un nivell de confiança del 95%.

Podem veure que tenim quatre grups diferents (4 tipus de combustibles) que volem comparar. A partir del test realitzat hi ha evidències de que la varianza no és la mateixa en tots el grups. Fet que ja podiem intuir al diagrama de caixes o boxplot on mostravem l'atribut 'rate.daily' envers 'fuelType'.




## Model de regressió lineal múltiple per preveure el preu diari d'un vehicle

A continuació ens proposem estimar per mínims quadrats ordinaris un model lineal que expliqui la variable *rate.daily* en funció de *age i renterTripsTaken*. En aquest cas farem servir només atributs numèrics. 

**Model de regressió lineal múltiple 1 (Preu ~ age + renterTripsTaken)**

```{r echo=TRUE, message=FALSE, warning=FALSE}
model.lm1 <- lm(formula=rate.daily ~ age + renterTripsTaken, data = ds)

summary(model.lm1)
```

Així doncs l'equació de regressió és:

$$\hat{y} = -0.0260*age - 0.0014 * renterTripsTaken + 4.46$$ 

Es pot observar que tant la variable *age i renterTripsTaken* són significatives perquè Pr(>|t|)< 0,05. 

Finalment el coeficient de determinació ajustat per aquest model és: R<sup>2</sup> = 0.03936. Això ens diu que el model de regressió múltiple obtingut explica el 3.936% de la variabilitat del preu del lloguer diari de vehicles. Com que és molt proper al 0%, en principi és un model bastant dolent, i per tant tindrà poc poder predictiu, gairebè nul.

Anem a veure ara si amb la introducció de noves variables al model, aconseguim un altre model que presenti una millor capacitat predictora. En aquest cas utilitzarem només atributs categòrics.

**Model de regressió lineal mùltiple 2 (Preu ~ age + renterTripsTaken + fuelType + vehicle.make + vehicle.type)**

```{r echo=TRUE, message=FALSE, warning=FALSE}
model.lm2 <- lm(formula=rate.daily ~ fuelType + vehicle.make + vehicle.type, data = ds)

summary(model.lm2)
```

Si examinem ara el coeficient de determinació ajustat per aquest nou model és: R<sup>2</sup> = 0.52. Això ens diu que el model de regressió múltiple obtingut explica el 52.22% de la variabilitat del preu del lloguer diari de vehicles. Com que és molt proper al 50%, en principi no és un model gaire bo, i per tant tindrà poc poder predictiu. Tot i així podem veure com hi ha un increment considerable sobre la variabilitat explicada respecte al primer model. A més, usant la variable **vehicle.make** que te 51 categories, sobre una mostra de menys de 6000 observacions, podem estar sobreajustant el model. En aquest sentit, fem a continuació la prova de crear una nova versió del mateix model amb la variable **range** (en lloc de **vehicle.make**).

**Model de regressió lineal mùltiple x (Preu ~ age + renterTripsTaken + fuelType + range + vehicle.type)**

```{r echo=TRUE, message=FALSE, warning=FALSE}
model.lm2_2 <- lm(formula=rate.daily ~ fuelType + range + vehicle.type, data = ds)

summary(model.lm2_2)
```
En aquest cas el coeficient de determinació és de 0.295. És inferior al model anterior però també és un mòdel molt més senzill i per tant robust. No obstant encara ens trobem lluny de poder obtenir una predicció prou "bona" de **rate.daily**.


**Model de regressió lineal mùltiple 3 (Preu ~ age + renterTripsTaken + fuelType + vehicle.make + vehicle.type)**

Ara probarem a generar un nou model, però aquest cop combinarem atributs categòrics i atributs numèrics com a variables predictores.

```{r echo=TRUE, message=FALSE, warning=FALSE}
model.lm3 <- lm(formula=rate.daily ~ age + renterTripsTaken + fuelType + vehicle.make + vehicle.type, data = ds)

summary(model.lm3)
```

Si examinem ara el coeficient de determinació ajustat per aquest nou model és: R<sup>2</sup> = 0.5356. Això ens diu que el model de regressió múltiple obtingut explica el 53.56% de la variabilitat del preu del lloguer diari de vehicles. Com que és molt proper al 50%, en principi no és un model gaire bo, i per tant tindrà poc poder predictiu. Tot i així podem veure com hi ha un increment considerable sobre la variabilitat explicada respecte al primer model, i un increment poc significatiu respecte el segon model. La qual cosa ens indica que a priori els atributs que millor expliquen el preu en un model lineal són les característiques del vehicle: el combustible, la marca i el tipus de vehicle, però no el nombre de vegades que el vehicle ha estat usat.

Ara probarem de fer un nou el model usant, com abans la variable **range** enlloc de **vehicle.make** i afegint la variable **population.discr**.

```{r echo=TRUE, message=FALSE, warning=FALSE}
model.lm4 <- lm(formula=rate.daily ~ age + renterTripsTaken + fuelType + range + vehicle.type + population.discr, data = ds)

summary(model.lm4)
```
Podem observar que la millora obtinguda al afegir **population.discr** i **vehicle.type** és irrisoria i que per tant aquestes dues variables no afecten el resultat, almenys de forma lineal.

## Model d'arbre de regressió per preveure el preu diari d'un vehicle

Comencem triant el subconjunt d'entrenament i el de prova. Nosaltres crearem dos conjunts de dades directament amb un rang.

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Creem el conjunt d'entrenament i el de prova
set.seed(555)
indexes = sample(1:nrow(ds), size=floor((2/3)*nrow(ds)))
train <- ds[indexes,]
test  <- ds[-indexes,]
```

Després d'una extracció aleatòria de casos cal realitzar una anàlisi de dades mínim per assegurar-nos de no obtenir valors esbiaixats pels valors que conté cada mostra.

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Verifiquem les dimensions del conjunt d'entrenament
dim(train)
```


```{r echo=TRUE, message=FALSE, warning=FALSE}
# Verifiquem les dimensions del conjunt de prova
dim(test)
```

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Obtenim l'atribut de classe de la resta 
trainY <- train[,c('rate.daily')]
testY <- test[,c('rate.daily')]
```

**Model d'Arbre de regressió**

A continuació ens proposem generar un model d'arbre de regressió que expliqui la variable *rate.daily* en funció de les característiques del vehicle. 

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Generem el model d'arbre
model_cart_rate <- rpart(rate.daily ~ fuelType + location.city + location.state + vehicle.make + vehicle.model + vehicle.type, method="anova", data=train)

# Mostrem un resum de la generació de l'arbre
#summary(model_cart)

#printcp(model_cart_rate)

# Mostrem en un gràfic l'arbre obtingut
rpart.plot(model_cart_rate, cex=0.6)
```


Un cop generat el model, podem comprovar la seva qualitat predint la classe per a les dades de prova que hem reservat al principi.

```{r echo=TRUE, message=FALSE, warning=FALSE}
predicted_model_cart_rate <- predict(model_cart_rate, test, type = "vector")

# test RMSE
rmse_cart_rate <- rmse(predicted_model_cart_rate, testY)

# test MAE
mae_cart_rate <- mae(predicted_model_cart_rate, testY)

print(sprintf("RMSE: %.4f", rmse_cart_rate))

print(sprintf("MAE: %.4f", rmse_cart_rate))
```
Examinem els valors predits envers els valors reals.

```{r}
plot(predicted_model_cart_rate, testY, xlab = "Predicted", ylab = "Actual")
abline(0, 1)
```

Examinem la importància de cada una dels atributs predictors en el model.

```{r echo=TRUE, message=FALSE, warning=FALSE}
model_cart_rate$variable.importance
```
A partir del resultat obtingut podem veure que l'atribut que més influeix en el preu del lloguer dels vehicles és el model de cotxe.



**Model d'Arbre de regressió amb variables més simples**

A continuació ens proposem generar un model d'arbre de regressió que expliqui la variable *rate.daily* en funció de les característiques del vehicle. 

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Generem el model d'arbre
model_cart_rate_2 <- rpart(rate.daily ~ fuelType + range + population.discr + vehicle.type, method="anova", data=train)

# Mostrem un resum de la generació de l'arbre
#summary(model_cart)

#printcp(model_cart_rate)

# Mostrem en un gràfic l'arbre obtingut
rpart.plot(model_cart_rate_2, cex=0.8)
```


Un cop generat el model, podem comprovar la seva qualitat predint la classe per a les dades de prova que hem reservat al principi.

```{r echo=TRUE, message=FALSE, warning=FALSE}
predicted_model_cart_rate_2 <- predict(model_cart_rate_2, test, type = "vector")

# test RMSE
rmse_cart_rate_2 <- rmse(predicted_model_cart_rate_2, testY)

# test MAE
mae_cart_rate_2 <- mae(predicted_model_cart_rate_2, testY)

print(sprintf("RMSE: %.4f", rmse_cart_rate_2))

print(sprintf("MAE: %.4f", rmse_cart_rate_2))
```
Examinem els valors predits envers els valors reals.

```{r}
plot(predicted_model_cart_rate_2, testY, xlab = "Predicted", ylab = "Actual")
abline(0, 1)
```

Examinem la importància de cada una dels atributs predictors en el model.

```{r echo=TRUE, message=FALSE, warning=FALSE}
model_cart_rate_2$variable.importance
```
A partir del resultat obtingut podem veure que l'atribut que més influeix en el preu del lloguer dels vehicles és la gamma del cotxe **range**.





## Model d'arbre de classificació per preveure si un vehicle serà llogat

A continuació ens proposem generar un model d'arbre de classificació que expliqui la variable *rent* en funció de les característiques del vehicle. És a dir que ens permeti donades les característiques d'un vehicle predir si aquest serà llogat o no.

**Model d'Arbre de classificació**

Obtenim la classe objectiu

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Obtenim l'atribut de classe de la resta 
trainY <- train[,c('rent')]
testY <- test[,c('rent')]
```

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Generem el model d'arbre
model_cart_rent <- rpart(rent ~ fuelType + location.city + location.state + vehicle.make + vehicle.model + vehicle.type, method="class", data=train)

# Mostrem un resum de la generació de l'arbre
#summary(model_cart)

#printcp(model_cart_rent)

# Mostrem en un gràfic l'arbre obtingut
rpart.plot(model_cart_rent, cex=0.6)
```

Un cop generat el model, podem comprovar la seva qualitat predint la classe per a les dades de prova que hem reservat al principi.

```{r echo=TRUE, message=FALSE, warning=FALSE}
predicted_model_cart_rent <- predict(model_cart_rent, test, type = "class")

print(sprintf("La precisió de l'arbre és: %.4f %%", 100 * sum(predicted_model_cart_rent == testY) / length(predicted_model_cart_rent)))
```

Quan hi ha poques classes, la qualitat de la predicció també es pot analitzar mitjançant una matriu de confusió que identifica els tipus d'errors comesos.

```{r echo=TRUE, message=FALSE, warning=FALSE}
mat_conf_cart_rent <- table(testY, Predicted=predicted_model_cart_rent)

mat_conf_cart_rent
```

Una altra manera de calcular el percentatge de registres correctament classificats és utilitzant la matriu de confusió:

```{r echo=TRUE, message=FALSE, warning=FALSE}
porcentaje_correct <- 100 * sum(diag(mat_conf_cart_rent)) / sum(mat_conf_cart_rent)
print(sprintf("El %% de registres correctament classificats és: %.4f %%", porcentaje_correct))
```

A més, tenim a la nostra disposició el paquet gmodels per a obtenir informació més completa

```{r echo=TRUE, message=FALSE, warning=FALSE}
CrossTable(testY, predicted_model_cart_rent, prop.chisq  = FALSE, prop.c = FALSE, prop.r =FALSE, dnn = c('Reality', 'Prediction'))
```

Durant tot l'estudi previ em deixat de banda un fet important que es va veure durant la fase d'anàlisis del joc de dades. Si recordem el nombre d'observacions pertanyents a una classe respecte a l'altre és força diferent per a l'atribut objectiu 'rent'.

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Calculem histogrames de les variables de classe
ggplot(data=ds, aes(x = rent)) + 
  geom_bar(aes(y = (..count..)/sum(..count..))) + 
  geom_text(aes(y = ((..count..)/sum(..count..)), 
                label = scales::percent((..count..)/sum(..count..))), 
            stat = "count", 
            vjust = -0.5) + 
  scale_y_continuous(labels = scales::percent, limits = c(0,1)) + 
  xlab("Rent") + 
  ylab("Freqüència")
```

Les classificacions desequilibrades suposen un desafiament per a la generació de models de predicció, ja que la majoria dels algorismes utilitzats per a la classificació van ser dissenyats entorn l'assumpció d'un nombre igual d'observacions per a cada classe. Aixó produeix que els models obtinguts presentin un rendiment predictiu deficient, en concret per a la classe minoritària. A més aixó sol ser un problema perqué normalment, la classe minoritària és la més important i per tant el model és més sensible als errors de classificació de la classe minoritària que la classe majoritària.

Per tal de reduir els efectes causats per aquest fet proposem aplicar diferents mètodes de submostreig abans de generar els models.

```{r echo=TRUE, message=FALSE, warning=FALSE}
set.seed(2)

# Escollim els atributs sobre els quals treballarem
train.data <- train

train.data[,"Class"] <- train['rent']

test.data <- test

test.data[,"Class"] <- test['rent']

# Construïm diferents mostres a partir del conjunt de dades original

# Down sampling
down_train <- downSample(x = train.data[, -ncol(train.data)], y = train.data$Class)

# Up Sampling
up_train <- upSample(x = train.data[, -ncol(train.data)], y = train.data$Class)

# Mix up/down sampling SMOTE
smote_train <- SMOTE(Class ~ ., data = train.data)

# Mostrem el nombre d'observacions pertanyents a cada una de les clases després de la generació de mostres
# Conjunt original
table(train.data$Class)

# Down sampling
table(down_train$Class)

# Up sampling
table(up_train$Class)

# Smote sampling
table(smote_train$Class)
```

Un cop obtingudes diferents mostres del conjunt de dades originals amb submostreig anem a realitzar l'entrenament d'un model d'arbre de decisió (CART) per cada un dels subconjunts.

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Model training - CART
set.seed(4)
down_outside <- rpart(rent ~ fuelType + location.city + location.state + vehicle.make + vehicle.model + vehicle.type, method="class", data=down_train)

set.seed(5)
up_outside <- rpart(rent ~ fuelType + location.city + location.state + vehicle.make + vehicle.model + vehicle.type, method="class", data=up_train)

set.seed(6)
smote_outside <- rpart(rent ~ fuelType + location.city + location.state + vehicle.make + vehicle.model + vehicle.type, method="class", data=smote_train)

```

I per acabar realitzem les corresponents predicions en el conjunt de test

```{r echo=TRUE, message=FALSE, warning=FALSE}
predicted_model_cart_rent <- predict(down_outside, test.data, type = "class")

divisor = length(predicted_model_cart_rent)
print(sprintf("La precisió de l'arbre amb downsampling és: %.4f %%",
              100 * sum(predicted_model_cart_rent == test.data[,"Class"]) / divisor))

predicted_model_cart_rent <- predict(up_outside, test.data, type = "class")

divisor = length(predicted_model_cart_rent)
print(sprintf("La precisió de l'arbre amb upsampling és: %.4f %%",
              100 * sum(predicted_model_cart_rent == test.data[,"Class"]) / divisor))

predicted_model_cart_rent <- predict(smote_outside, test.data, type = "class")

divisor = length(predicted_model_cart_rent)
print(sprintf("La precisió de l'arbre amb smote sampling és: %.4f %%",
              100 * sum(predicted_model_cart_rent == test.data[,"Class"]) / divisor))
```
Tot i que podem veure que la precisió ha disminuit, pels models obtinguts després de realitzar un submostreig per tractar el conjunt desequilibrat, podem veure com aquests nous models ofereixen una millor resposta a la classe minoritària, la que recull el no llogar.


**Model d'Arbre de classificació simplificat**

Obtenim la classe objectiu

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Obtenim l'atribut de classe de la resta 
trainY <- train[,c('rent')]
testY <- test[,c('rent')]
```

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Generem el model d'arbre
model_cart_rent_2 <- rpart(rent ~ fuelType + population.discr + range + vehicle.type, method="class", data=train)

# Mostrem un resum de la generació de l'arbre
#summary(model_cart)

#printcp(model_cart_rent)

# Mostrem en un gràfic l'arbre obtingut
rpart.plot(model_cart_rent_2)
```

Un cop generat el model, podem comprovar la seva qualitat predint la classe per a les dades de prova que hem reservat al principi.

```{r echo=TRUE, message=FALSE, warning=FALSE}
predicted_model_cart_rent_2 <- predict(model_cart_rent_2, test, type = "class")

print(sprintf("La precisió de l'arbre és: %.4f %%",
              100 * sum(predicted_model_cart_rent_2 == testY) / length(predicted_model_cart_rent_2)))
```

Quan hi ha poques classes, la qualitat de la predicció també es pot analitzar mitjançant una matriu de confusió que identifica els tipus d'errors comesos.

```{r echo=TRUE, message=FALSE, warning=FALSE}
mat_conf_cart_rent_2 <- table(testY, Predicted=predicted_model_cart_rent_2)

mat_conf_cart_rent_2
```

Una altra manera de calcular el percentatge de registres correctament classificats és utilitzant la matriu de confusió:

```{r echo=TRUE, message=FALSE, warning=FALSE}
porcentaje_correct_2 <- 100 * sum(diag(mat_conf_cart_rent_2)) / sum(mat_conf_cart_rent_2)
print(sprintf("El %% de registres correctament classificats és: %.4f %%", porcentaje_correct_2))
```

A més, tenim a la nostra disposició el paquet gmodels per a obtenir informació més completa

```{r echo=TRUE, message=FALSE, warning=FALSE}
CrossTable(testY, predicted_model_cart_rent_2, prop.chisq  = FALSE, prop.c = FALSE, prop.r =FALSE, dnn = c('Reality', 'Prediction'))
```

Durant tot l'estudi previ em deixat de banda un fet important que es va veure durant la fase d'anàlisis del joc de dades. Si recordem el nombre d'observacions pertanyents a una classe respecte a l'altre és força diferent per a l'atribut objectiu 'rent'.

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Calculem histogrames de les variables de classe
ggplot(data=ds, aes(x = rent)) + 
  geom_bar(aes(y = (..count..)/sum(..count..))) + 
  geom_text(aes(y = ((..count..)/sum(..count..)), 
                label = scales::percent((..count..)/sum(..count..))), 
            stat = "count", 
            vjust = -0.5) + 
  scale_y_continuous(labels = scales::percent, limits = c(0,1)) + 
  xlab("Rent") + 
  ylab("Freqüència")
```

Les classificacions desequilibrades suposen un desafiament per a la generació de models de predicció, ja que la majoria dels algorismes utilitzats per a la classificació van ser dissenyats entorn l'assumpció d'un nombre igual d'observacions per a cada classe. Aixó produeix que els models obtinguts presentin un rendiment predictiu deficient, en concret per a la classe minoritària. A més aixó sol ser un problema perqué normalment, la classe minoritària és la més important i per tant el model és més sensible als errors de classificació de la classe minoritària que la classe majoritària.

Per tal de reduir els efectes causats per aquest fet proposem aplicar diferents mètodes de submostreig abans de generar els models.

```{r echo=TRUE, message=FALSE, warning=FALSE}
set.seed(2)

# Escollim els atributs sobre els quals treballarem
train.data <- train

train.data[,"Class"] <- train['rent']

test.data <- test

test.data[,"Class"] <- test['rent']

# Construïm diferents mostres a partir del conjunt de dades original

# Down sampling
down_train <- downSample(x = train.data[, -ncol(train.data)], y = train.data$Class)

# Up Sampling
up_train <- upSample(x = train.data[, -ncol(train.data)], y = train.data$Class)

# Mix up/down sampling SMOTE
smote_train <- SMOTE(Class ~ ., data = train.data)

# Mostrem el nombre d'observacions pertanyents a cada una de les clases després de la generació de mostres
# Conjunt original
table(train.data$Class)

# Down sampling
table(down_train$Class)

# Up sampling
table(up_train$Class)

# Smote sampling
table(smote_train$Class)
```

Un cop obtingudes diferents mostres del conjunt de dades originals amb submostreig anem a realitzar l'entrenament d'un model d'arbre de decisió (CART) per cada un dels subconjunts.

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Model training - CART
set.seed(4)
down_outside <- rpart(rent ~ fuelType + population.discr + range + vehicle.type, method="class", data=down_train)

set.seed(5)
up_outside <- rpart(rent ~ fuelType + population.discr + range + vehicle.type, method="class", data=up_train)

set.seed(6)
smote_outside <- rpart(rent ~ fuelType + population.discr + range  + vehicle.type, method="class", data=smote_train)

```

I per acabar realitzem les corresponents predicions en el conjunt de test

```{r echo=TRUE, message=FALSE, warning=FALSE}
predicted_model_cart_rent_2 <- predict(down_outside, test.data, type = "class")

divisor = length(predicted_model_cart_rent_2)
print(sprintf("La precisió de l'arbre amb downsampling és: %.4f %%", 
              100 * sum(predicted_model_cart_rent_2 == test.data[,"Class"]) / divisor))

predicted_model_cart_rent_2 <- predict(up_outside, test.data, type = "class")

divisor = length(predicted_model_cart_rent_2)
print(sprintf("La precisió de l'arbre amb upsampling és: %.4f %%", 
              100 * sum(predicted_model_cart_rent_2 == test.data[,"Class"]) / divisor))

predicted_model_cart_rent_2 <- predict(smote_outside, test.data, type = "class")

divisor = length(predicted_model_cart_rent_2)
print(sprintf("La precisió de l'arbre amb smote sampling és: %.4f %%", 
              100 * sum(predicted_model_cart_rent_2 == test.data[,"Class"]) / divisor))
```
Tot i que podem veure que la precisió ha disminuit, pels models obtinguts després de realitzar un submostreig per tractar el conjunt desequilibrat, podem veure com aquests nous models ofereixen una millor resposta a la classe minoritària, la que recull el no llogar.



## Conclusions

A l'inici d'aquest estudi ens proposavem realitzar una anàlisi detallada dels atributs propis del sector del lloguer de vehicles per tal d’extreuren nou coneixement i que aquest pugui aportar valor.

Per això hem començat el nostre estudi amb les tasques típiques d'un procés de mineria o anàlica de dades, incloent la neteja de dades, la imputació de valors nuls, el tractament de valors extrems, la transformació d'alguns atributs i la creació d'atributs nous. També hem realitzat una primera inspecció visual de les dades on ja s'han pogut determinar certes relacions entre variables. Com per exemple que el preu diari de lloguer depén de la marca i el tipus de vehicle, el combustible que utilitza o la seva ubicació.

Tot seguit hem dut a terme diferents contrastos d’hipótesis que ens han permés identificar propietats interessants subjacents en les mostres que puguin ser inferides respecte a la població. Però primerament hem avaluat la normalitat dels principals atributs. A partir dels diferents resultats obtinguts podem concloure que:

*  Que els cotxes électrics tenen un lloguer més elevat que els de benzina, amb un nivell de confiança del 95%.
* Que la proporció de furgonetes de lloguer és més petita que la d’utilitàris, amb un nivell de confiança del 95%.
* Que el preu diari del lloguer del vehicle depén del tipus de vehicle, amb un nivell de confiança del 95%.
* Que el preu diari del lloguer del vehicle depén del tipus de combustible, amb un nivell de confiança del 95%.

A continuació hem generat un model per intentar preveure el preu per dia d’un automòbil de lloguer, a partir de les seves característiques. Tant mitjançant un model basat en regressió lineal múltiple com amb un arbre de regressió. Usant aquest dos tipus de models no s'ha pogut obtenir una predicció que poguem calificar com a bona. No obstant s'ha pogut determinar els atributs més influents en el preu diari del lloguer dels vehicles. Aquests són el model, la marca del vehicle i la seva localització. 

Finalment hem generat també un model que permet preveure, donades les característiques d’un vehicle de lloguer, si aquest serà llogat o no mitjançant un arbre de decisió per a classificació.


\newpage
# Bibliografia
[@danielliviano; @edwin; @josepgibergans2; @pawel]